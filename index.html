<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pummel Party Pro Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; font-family: sans-serif; }
        #ui { position: absolute; bottom: 20px; width: 100%; display: flex; flex-direction: column; align-items: center; pointer-events: none; }
        .info { background: rgba(0, 0, 0, 0.7); color: white; padding: 10px 25px; border-radius: 30px; margin-bottom: 10px; border: 1px solid #ff9d00; }
        button { pointer-events: auto; background: #ff9d00; border: none; padding: 15px 35px; font-size: 20px; color: white; border-radius: 15px; font-weight: bold; box-shadow: 0 4px #d35400; }
        button:active { box-shadow: 0 2px #d35400; transform: translateY(2px); }
    </style>
</head>
<body>

    <div id="ui">
        <div class="info" id="status">Ø¬Ù‡Ø² Ù†ÙØ³Ùƒ.. Ø¯ÙˆØ± Ø§Ù„Ù„Ø§Ø¹Ø¨ 1</div>
        <button id="rollBtn">Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯ ğŸ²</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ---
        const scene = new THREE.Scene();
        // Ø¥Ø¶Ø§ÙØ© Ø³Ù…Ø§Ø¡ Ù…ØªØ¯Ø±Ø¬Ø©
        scene.background = new THREE.Color(0x87ceeb); // Ù„ÙˆÙ† Ø³Ù…Ø§Ø¡ ØµØ§ÙÙŠÙ‡
        scene.fog = new THREE.Fog(0x87ceeb, 10, 50); // Ø¶Ø¨Ø§Ø¨ Ù„Ø¥Ø¹Ø·Ø§Ø¡ Ù…Ø¯Ù‰ ÙˆØ§Ù‚Ø¹ÙŠ

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 2. Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© ÙˆØ§Ù„Ø£Ø±Ø¶ÙŠØ© ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Ø£Ø±Ø¶ÙŠØ© Ø¹Ø´Ø¨ÙŠØ© ÙƒØ¨ÙŠØ±Ø©
        const groundGeo = new THREE.PlaneGeometry(100, 100);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x27ae60 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- 3. ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…Ø³Ø§Ø± (30 Ø®Ø·ÙˆØ© Ù…ØªØ´Ø¹Ø¨Ø©) ---
        const pathPoints = [];
        for (let i = 0; i < 30; i++) {
            // Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø¨Ø³ÙŠØ·Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø± Ù…ØªØ¹Ø±Ø¬
            let x = Math.sin(i * 0.5) * 5;
            let z = i * -2;
            pathPoints.push({ x, z });
            
            // Ø±Ø³Ù… Ø§Ù„Ø¨Ù„Ø§Ø·Ø©
            const tile = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.5, 2),
                new THREE.MeshStandardMaterial({ color: i % 5 === 0 ? 0xe74c3c : 0xf1c40f })
            );
            tile.position.set(x, 0.25, z);
            tile.receiveShadow = true;
            scene.add(tile);
        }

        // --- 4. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† (Ø´Ø®ØµÙŠØ§Øª Ù…Ø·ÙˆØ±Ø©) ---
        function createCharacter(color) {
            const group = new THREE.Group();
            
            // Ø§Ù„Ø¬Ø³Ù… (ÙƒØ¨Ø³ÙˆÙ„Ø©)
            const body = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.4, 0.6, 4, 8),
                new THREE.MeshStandardMaterial({ color: color })
            );
            body.position.y = 0.7;
            body.castShadow = true;
            group.add(body);

            // Ø§Ù„Ø¹ÙŠÙˆÙ† (ÙƒØ±Ø§Øª ØµØºÙŠØ±Ø© Ø¨ÙŠØ¶Ø§Ø¡)
            const eyeGeo = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            const eye1 = new THREE.Mesh(eyeGeo, eyeMat);
            eye1.position.set(0.15, 1, 0.3);
            group.add(eye1);

            const eye2 = new THREE.Mesh(eyeGeo, eyeMat);
            eye2.position.set(-0.15, 1, 0.3);
            group.add(eye2);

            scene.add(group);
            return group;
        }

        const players = [
            { mesh: createCharacter(0xff3e3e), posIndex: 0 },
            { mesh: createCharacter(0x3498db), posIndex: 0 },
            { mesh: createCharacter(0x2ecc71), posIndex: 0 }
        ];

        let turn = 0;

        function updatePositions() {
            players.forEach((p, i) => {
                const target = pathPoints[p.posIndex];
                // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ© Ø¨Ø³Ù„Ø§Ø³Ø©
                p.mesh.position.set(target.x + (i * 0.5 - 0.5), 0, target.z);
            });
            // ØªØ­Ø±ÙŠÙƒ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù†Ø´Ø·
            const activePlayer = players[turn].mesh.position;
            controls.target.set(activePlayer.x, 0, activePlayer.z);
        }

        // --- 5. Ù…Ù†Ø·Ù‚ Ø§Ù„Ù„Ø¹Ø¨ ---
        document.getElementById('rollBtn').onclick = () => {
            const roll = Math.floor(Math.random() * 6) + 1;
            players[turn].posIndex = Math.min(players[turn].posIndex + roll, 29);
            
            document.getElementById('status').innerText = `Ø§Ù„Ù„Ø§Ø¹Ø¨ ${turn + 1} ØªØ­Ø±Ùƒ ${roll} Ø®Ø·ÙˆØ§Øª!`;
            
            turn = (turn + 1) % 3;
            updatePositions();
        };

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        updatePositions();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
